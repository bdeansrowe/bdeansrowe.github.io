// test code generated by unit-test.dev

// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
};

// __tests__/script.test.js

const { half_edges_from_edge, facing, add_outgoing_hedges, doit, load_json } = require('../path/to/your/script');

// Mock document and canvas elements
const fs = require('fs');
const path = require('path');

beforeEach(() => {
  document.body.innerHTML = fs.readFileSync(path.resolve(__dirname, './mock.html'), 'utf8');
});

describe('half_edges_from_edge', () => {
  it('should properly add half edges and their twins for a given edge', () => {
    const edges = [];
    const edge = [0, 1];
    const edex = 0;

    const result = half_edges_from_edge(edges, edge, edex);
    const expected = [
      { hedge: [0, 1], twin: 1 },
      { hedge: [1, 0], twin: 0 },
    ];

    expect(result).toEqual(expected);
  });
});

describe('facing', () => {
  it('should return positive if face is front-facing', () => {
    const f = [0, 1, 2];
    const verticies = [[0, 0], [1, 0], [0, 1]];

    expect(facing(f, verticies)).toBeGreaterThan(0);
  });

  it('should return negative if face is back-facing', () => {
    const f = [0, 1, 2];
    const verticies = [[0, 0], [0, 1], [1, 0]];

    expect(facing(f, verticies)).toBeLessThan(0);
  });

  it('should return zero if the face has no area (degenerate case)', () => {
    const f = [0, 1, 2];
    const verticies = [[0, 0], [1, 1], [2, 2]];

    expect(facing(f, verticies)).toBe(0);
  });
});

describe('add_outgoing_hedges', () => {
  it('should add outgoing hedges and calculate angles', () => {
    const hedges = [
      { hedge: [0, 1] }, { hedge: [1, 0] }, { hedge: [1, 2] }, 
      { hedge: [2, 1] }
    ];
    const vertices = [[0, 0], [1, 0], [1, 1]];

    const adder = add_outgoing_hedges(hedges);
    const vert_plus = adder([], vertices[0], 0, vertices);
    const expectedOutput = [
      {
        vertex: [0, 0],
        outgoing: [
          { hedge: 0, angle: 0 },
        ],
      },
    ];

    expect(vert_plus).toEqual(expectedOutput);
  });
});

describe('load_json', () => {
  it('should load and parse JSON file correctly', (done) => {
    const fileContent = JSON.stringify({
      vertices: [[0, 0], [1, 0], [1, 1]],
      edges: [[0, 1], [1, 2]],
    });

    const file = new File([fileContent], 'test.json', { type: 'application/json' });
    const fileInput = document.getElementById('input');
    Object.defineProperty(fileInput, 'files', {
      value: [file],
    });

    load_json(file);
 setTimeout(() => {
      expect(document.getElementById('data').innerHTML).toContain('Vertices: [0,0] [1,0] [1,1]');
      expect(document.getElementById('data').innerHTML).toContain('Edges: [0,1] [1,2]');
      done();
    }, 500);
  });
});

describe('doit', () => {
  it('should process geometrical data and display faces correctly', () => {
    const mockData = {
      vertices: [[0, 0], [1, 0], [1, 1], [0, 1]],
      edges: [[0, 1], [1, 2], [2, 3], [3, 0]],
    };
    document.getElementById('data').innerHTML = '';
    window.json_data = JSON.stringify(mockData);
    window.vertices = mockData.vertices;
    window.edges = mockData.edges;

    doit();

    expect(document.getElementById('result').innerHTML).toContain('Faces');
    expect(document.getElementById('result').innerHTML).toContain('f0: 0,1,2,3,0');
  });
});
